### 我的采坑之旅

1.子元素width 100% 只会继承width 不会加padding 或者margin border值

2.变量提升

在es6之前允许先使用变量在定义

对于es6

允许在块级作用域内声明函数。

注：函数声明类似于`var`，即会提升到全局作用域或函数作用域的头部。

同时，函数声明还会提升到所在的块级作用域的头部。

因此应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式(不会变量提升)，而不是函数声明语句。

~~~javascript
a = 'xxx';
var a ; 
console.log(a);
//1
(function(){
  foo();
  function foo(){
    console.log(1);
  }
})() 
//1
注 函数表达式不支持变量提升
例：(function(){
  foo();
  var foo = function(){
    console.log(1);
  }
})() //报错

var name="zhangsan";
function GetName(){
  name = "lisi";
  var arr = [1,2,3];
  var name ="wangwu" + arr;  //注此时在函数内部用var声明了name变量 故name为局部变量和外面变量没关系 如果不用var 声明而是直接变成 name = 'lisi'，则会上升到全局变量
  console.log(name);//wangwu1,2,3
}
GetName();
console.log(name);//zhangsan
~~~



想要块级作用域返回值

~~~javascript
在块级作用域之前加上do，使它变为do表达式，然后就会返回内部最后执行的表达式的值。
let x = do {
  let t = f();
  t * t + 1;
}; // x = t * t +1;
~~~

3.this指向

**this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁**，**实际上this的最终指向的是那个调用它的对象**

```javascript
例子1
function a(){
    var user = "追梦子";
    console.log(this.user); //undefined
    console.log(this); //Window
}
a();
按照我们上面说的this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，下面的代码就可以证明。
function a(){
    var user = "追梦子";
    console.log(this.user); //undefined
    console.log(this);　　//Window
}
window.a();

例子2
var o = {
    user:"追梦子",
    fn:function(){
        console.log(this.user);  //追梦子
    }
}
o.fn();
这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o

例子3
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //12
        }
    }
}
o.b.fn();
这里同样也是对象o点出来的，但是同样this并没有指向它。
事实上
情况1: 如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window。
情况2: 如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。
情况3: 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。

例
var o = {
    a:10,
    b:{
        // a:12,
        fn:function(){
            console.log(this.a); //undefined
        }
    }
}
o.b.fn();
尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。

还有一种比较特殊的情形
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();
这时候由于是在window环境下调用的  故 this 指向window

对于构造函数

function Fn(){
    this.user = "追梦子";
}
var a = new Fn();
console.log(a.user); //追梦子
由于 构造函数的new关键字 创建一个对象实例， 并且返回它 。 调用这个函数的是对象a  所以this的指向为a  

当this 碰到return 时候
如果返回的是一个对象
function fn()  
{  
    this.user = '追梦子';  
    return function(){};//return {}
}
var a = new fn();  
console.log(a.user); //undefined
那么 this 指向的就是返回的那个对象
```



~~~
apply  call bind 区别与联系
三者都是改变上下文的this环境
单独来说 apply call实现功能都一样，区别是 给apply传递的第二个参数为数组，而call则不用
对于bind  bind 返回值是一个函数
也就是说 如果想要 同apply call一样立即调用 需要加xxx.bind(xxx)()   

function f(){
  x = 1;
}
function b (){
  x = 4
  return this.x
}
b.call(f);

this 问题
	情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。

　情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。

　情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，
　总之  this 是在调用的时候确定的，  除了用apply之类的方法改变， 他指向上一级调用他的对象，  
　还有 箭头函数 中 由于绑定的问题， 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
~~~

4.for of与for in

for in用来遍历对象，

for of用来遍历数组，

~~~
for(val in obj){
    console.log(val)
}
其中for in 得到的是索引 （即键名）
for of 得到的是元素值
~~~

for in也可以遍历数组，但是不推荐

原因是

1.index索引为字符串型数字，不能直接进行几何运算

2.遍历顺序有可能不是按照实际数组的内部顺序

3.使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性

所以for in更适合遍历对象，不要使用for in遍历数组。