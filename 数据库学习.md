#### MongoDB

MongoDB是一个面向文档，schema无关的数据库，非常适合Node.js应用以及云端部署

与MySQL和PostgreSQL是根据固定的解构设计（schema）将数据存储在表中不同，MongoDB可以将任意类型的文档数据存储到集合中（schema无关）

#### Mysql

关于大小写问题，在LINUX系统下是严格区分大小写的

但是在windows下 不严格区分， 因此select * from 和SELECT * from 效果一样

+ 创建数据库

  `mysqladmin -u root -p create  database`

		创建了名字为database的数据库  

+ 删除数据库
  `mysqladmin -u root -p drop database`

+ 选择数据库

  ~~~
  mysql -u root -p

  use database

  今后所有的操作将在database数据库里面进行

  ~~~

+ Mysql数值类型

  MySQL支持所有标准SQL数值数据类型。

  这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。

  关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。

  BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。

  作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT

  常用的如

  ~~~
  数值类
  INT/INTEGER  大整数类型 4字节
  FLOAT 单精度浮点类 4字节
  DOUBLE 双精度浮点类 8字节

  日期类
  DATA  3字节  格式 YYYY-MM-DD 用途 日期值
  TIME  3字节  格式 HH:MM:SS  用途 时间值
  YEAR  1字节  格式 YYYY  用途 年份值
  DATATIME 8字节 格式 YYYY-MM-DD HH:MM:SS 
  TIMESTAMP 4字节 格式 YYYYMMDD HHMMSS

  字符类
  CHAR   0-255字节 定长
  VARCHAR    不定长 0-65535 字节
  BLOB  二进制形式的长文本数据  0-65535 字节
  TEXT  长文本数据
  ~~~


  

+ 创建数据表

  `CREATE TABLE table_name (column_name column_type);`

  ~~~
    将在 RUNOOB 数据库中创建数据表runoob_tbl：

    root@host# mysql -u root -p

    Enter password:***

    mysql> use RUNOOB;

    Database changed

    mysql> CREATE TABLE runoob_tbl(

       -> runoob_id INT NOT NULL AUTO_INCREMENT,

       -> runoob_title VARCHAR(100) NOT NULL,

       -> runoob_author VARCHAR(40) NOT NULL,

       -> submission_date DATE,

       -> PRIMARY KEY ( runoob_id )

       -> )ENGINE=InnoDB DEFAULT CHARSET=utf8;

    Query OK, 0 rows affected (0.16 sec)
    mysql>
  ~~~

  ​

  如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL， 在操作数据库时如果输入该字段的数据为NULL ，就会报错。
  AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。
  PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。
  ENGINE 设置存储引擎，CHARSET 设置编码。

  ~~~

  ~~~

+ 显示数据表 

  `show tables`	  

  `desc sometable` 显示sometable 这个数据表

+ 删除数据表

  ~~~
  root@host# mysql -u root -p
  Enter password:*******
  mysql> use RUNOOB;
  Database changed
  mysql> DROP TABLE runoob_tbl 
  Query OK, 0 rows affected (0.8 sec)
  mysql>
  ~~~

+ Mysql插入数据

  ~~~
  通用的INSERT INTO 语法
  INSERT INTO table_name ( field1, field2,...fieldN )
                         	VALUES
                         ( value1, value2,...valueN );
  例
  root@host# mysql -u root -p password;
  Enter password:*******
  mysql> use RUNOOB;
  Database changed
  mysql> INSERT INTO runoob_tbl 
      -> (runoob_title, runoob_author, submission_date)
      -> VALUES
      -> ("学习 PHP", "菜鸟教程", NOW());
  Query OK, 1 rows affected, 1 warnings (0.01 sec)
  mysql> INSERT INTO runoob_tbl
      -> (runoob_title, runoob_author, submission_date)
      -> VALUES
      -> ("学习 MySQL", "菜鸟教程", NOW());
  Query OK, 1 rows affected, 1 warnings (0.01 sec)
  mysql> INSERT INTO runoob_tbl
      -> (runoob_title, runoob_author, submission_date)
      -> VALUES
      -> ("JAVA 教程", "RUNOOB.COM", '2016-05-06');
  Query OK, 1 rows affected (0.00 sec)
  mysql>
  ~~~


  ~~~

  select * from runoob_tbl;

  输出结果：

  ![img](http://www.runoob.com/wp-content/uploads/2014/03/71971E68-78B3-4964-AC4C-E75114D3B5B5.jpg)

+ Mysql 查询数据

  ~~~
  SELECT column_name,column_name
  FROM table_name
  [WHERE Clause]
  [LIMIT N][ OFFSET M]

  查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。
  SELECT 命令可以读取一条或者多条记录。
  你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据
  你可以使用 WHERE 语句来包含任何条件。
  你可以使用 LIMIT 属性来设定返回的记录数。
  你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。

  ~~~

+ Mysql WHERE 子句

  ~~~
  用来有条件的筛选数据
  SELECT field1, field2,...fieldN FROM table_name1, table_name2...
  [WHERE condition1 [AND [OR]] condition2.....

  可以用AND 或者OR指定一个或多个条件 WHERE子句类似于IF条件

  SELECT * from runoob_tbl WHERE runoob_author='菜鸟教程';
  选择 runoob_tbl 表中 runoob_author =‘菜鸟教程‘ 的数据

  WHERE 子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定 WHERE 子句的字符串比较是区分大小写的。

  mysql> SELECT * from runoob_tbl WHERE BINARY runoob_author='runoob.com';
  Empty set (0.01 sec)

  mysql> SELECT * from runoob_tbl WHERE BINARY runoob_author='RUNOOB.COM';
  ~~~

+ Mysql UPDATE 查询

  如果我们需要修改或更新 MySQL 中的数据，我们可以使用 SQL UPDATE 命令来操作。.

  ~~~
  UPDATE table_name SET field1=new-value1, field2=new-value2
  [WHERE Clause]

  你可以同时更新一个或多个字段。
  你可以在 WHERE 子句中指定任何条件。
  你可以在一个单独表中同时更新数据。

  以下实例将更新数据表中 runoob_id 为 3 的 runoob_title 字段值：
  mysql> UPDATE runoob_tbl SET runoob_title='学习 C++' WHERE runoob_id=3;
  Query OK, 1 rows affected (0.01 sec)

  mysql> SELECT * from runoob_tbl WHERE runoob_id=3;
  +-----------+--------------+---------------+-----------------+
  | runoob_id | runoob_title | runoob_author | submission_date |
  +-----------+--------------+---------------+-----------------+
  | 3         | 学习 C++   | RUNOOB.COM    | 2016-05-06      |
  +-----------+--------------+---------------+-----------------+
  1 rows in set (0.01 sec)
  ~~~

+ Mysql DELETE 语句

  ```
  DELETE FROM table_name [WHERE Clause]

  如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。
  你可以在 WHERE 子句中指定任何条件
  您可以在单个表中一次性删除记录。
  ```

+ Mysql LIKE 语句

  WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 "runoob_author = 'RUNOOB.COM'"。

  但是有时候我们需要获取 runoob_author 字段含有 "COM" 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。

  SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。

  ~~~
  SELECT field1, field2,...fieldN 
  FROM table_name
  WHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue'

  你可以在 WHERE 子句中指定任何条件。
  你可以在 WHERE 子句中使用LIKE子句。
  你可以使用LIKE子句代替等号 =。
  LIKE 通常与 % 一同使用，类似于一个元字符的搜索。
  你可以使用 AND 或者 OR 指定一个或多个条件。
  你可以在 DELETE 或 UPDATE 命令中使用 WHERE...LIKE 子句来指定条件。

  mysql> use RUNOOB;
  Database changed
  mysql> SELECT * from runoob_tbl  WHERE runoob_author LIKE '%COM';
  +-----------+---------------+---------------+-----------------+
  | runoob_id | runoob_title  | runoob_author | submission_date |
  +-----------+---------------+---------------+-----------------+
  | 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |
  | 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |
  +-----------+---------------+---------------+-----------------+
  2 rows in set (0.01 sec)
  ~~~

+ Mysql UNION操作符

  MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。

  ~~~
  SELECT expression1, expression2, ... expression_n
  FROM tables
  [WHERE conditions]
  UNION [ALL | DISTINCT]
  SELECT expression1, expression2, ... expression_n
  FROM tables
  [WHERE conditions];

  expression1, expression2, ... expression_n: 要检索的列。
  tables: 要检索的数据表。
  WHERE conditions: 可选， 检索条件。
  DISTINCT: 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。
  ALL: 可选，返回所有结果集，包含重复数据。
  ~~~

+ Mysql 排序

  ~~~
  SELECT field1, field2,...fieldN table_name1, table_name2...
  ORDER BY field1, [field2...] [ASC [DESC]]

  你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。
  你可以设定多个字段来排序。
  你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。
  你可以添加 WHERE...LIKE 子句来设置条件。

  mysql> use RUNOOB;
  Database changed
  mysql> SELECT * from runoob_tbl ORDER BY submission_date ASC;
  +-----------+---------------+---------------+-----------------+
  | runoob_id | runoob_title  | runoob_author | submission_date |
  +-----------+---------------+---------------+-----------------+
  | 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |
  | 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |
  | 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |
  | 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |
  +-----------+---------------+---------------+-----------------+

  mysql> SELECT * from runoob_tbl ORDER BY submission_date DESC;
  +-----------+---------------+---------------+-----------------+
  | runoob_id | runoob_title  | runoob_author | submission_date |
  +-----------+---------------+---------------+-----------------+
  | 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |
  | 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |
  | 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |
  | 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |
  +-----------+---------------+---------------+-----------------+
  ~~~

+ Mysql 分组 GROUP BY语句

  GROUP BY 语句根据一个或多个列对结果集进行分组。

  在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。

  ~~~
  SELECT column_name, function(column_name)
  FROM table_name
  WHERE column_name operator value
  GROUP BY column_name;

  mysql> set names utf8;
  mysql> SELECT * FROM employee_tbl;
  +----+--------+---------------------+--------+
  | id | name   | date                | singin |
  +----+--------+---------------------+--------+
  |  1 | 小明 | 2016-04-22 15:25:33 |      1 |
  |  2 | 小王 | 2016-04-20 15:25:47 |      3 |
  |  3 | 小丽 | 2016-04-19 15:26:02 |      2 |
  |  4 | 小王 | 2016-04-07 15:26:14 |      4 |
  |  5 | 小明 | 2016-04-11 15:26:40 |      4 |
  |  6 | 小明 | 2016-04-04 15:26:54 |      2 |
  +----+--------+---------------------+--------+


  mysql> SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;
  +--------+----------+
  | name   | COUNT(*) |
  +--------+----------+
  | 小丽 |        1 |
  | 小明 |        3 |
  | 小王 |        2 |
  +--------+----------+

  使用 WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计 	
  mysql> SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;
  +--------+--------------+
  | name   | singin_count |
  +--------+--------------+
  | 小丽 |            2 |
  | 小明 |            7 |
  | 小王 |            7 |
  | NULL   |           16 |
  +--------+--------------+

  其中记录 NULL 表示所有人的登录次数。

  我们可以使用 coalesce 来设置一个可以取代 NUll 的名称，coalesce 语法：
  select coalesce(a,b,c);
  如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。
  以下实例中如果名字为空我们使用总数代替：

  mysql> SELECT coalesce(name, '总数'), SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;
  +--------------------------+--------------+
  | coalesce(name, '总数') | singin_count |
  +--------------------------+--------------+
  | 小丽                   |            2 |
  | 小明                   |            7 |
  | 小王                   |            7 |
  | 总数                   |           16 |
  +--------------------------+--------------+
  4 rows in set (0.01 sec)
  ~~~



+ Mysql 连接的使用

   MySQL 的 JOIN 在两个或多个表中查询数据。

  你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。

  ~~~
  INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
  LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
  RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。
  ~~~

  ~~~
  mysql> use RUNOOB;
  Database changed
  mysql> SELECT * FROM tcount_tbl;
  +---------------+--------------+
  | runoob_author | runoob_count |
  +---------------+--------------+
  | 菜鸟教程  | 10           |
  | RUNOOB.COM    | 20           |
  | Google        | 22           |
  +---------------+--------------+
  3 rows in set (0.01 sec)

  mysql> SELECT * from runoob_tbl;
  +-----------+---------------+---------------+-----------------+
  | runoob_id | runoob_title  | runoob_author | submission_date |
  +-----------+---------------+---------------+-----------------+
  | 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |
  | 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |
  | 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |
  | 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |
  | 5         | 学习 C      | FK            | 2017-04-05      |
  +-----------+---------------+---------------+-----------------+


  mysql> SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
  +-------------+-----------------+----------------+
  | a.runoob_id | a.runoob_author | b.runoob_count |
  +-------------+-----------------+----------------+
  | 1           | 菜鸟教程    | 10             |
  | 2           | 菜鸟教程    | 10             |
  | 3           | RUNOOB.COM      | 20             |
  | 4           | RUNOOB.COM      | 20             |
  +-------------+-----------------+----------------+

  等价于
  SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;

  顾名思义 使用join 语句 （INNER JOIN）来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值
  ~~~

+ Mysql NULL值处理

  ~~~
  IS NULL: 当列的值是 NULL,此运算符返回 true。
  IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。
  <=>: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。
   = 与 != 对于NULL的处理是不起作用的
  mysql> SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;
  +---------------+--------------+
  | runoob_author | runoob_count |
  +---------------+--------------+
  | 菜鸟教程  | NULL         |
  | Google        | NULL         |
  +---------------+--------------+
  ~~~

+ Mysql正则表达式

+ Mysql事务

  MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！

  - 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
  - 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
  - 事务用来管理 insert,update,delete 语句

  事务必须满足4个条件（ACID）：：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

  - **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
  - **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
  - **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
  - **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

  **事物控制语句**

  - BEGIN或START TRANSACTION；显式地开启一个事务；
  - COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；
  - ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
  - SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；
  - RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
  - ROLLBACK TO identifier；把事务回滚到标记点；
  - SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。

  ### MYSQL 事务处理主要有两种方法：

  1、用 BEGIN, ROLLBACK, COMMIT来实现

  - **BEGIN** 开始一个事务
  - **ROLLBACK** 事务回滚
  - **COMMIT** 事务确认

  2、直接用 SET 来改变 MySQL 的自动提交模式:

  - **SET AUTOCOMMIT=0** 禁止自动提交
  - **SET AUTOCOMMIT=1** 开启自动提交

  ~~~
  mysql> use RUNOOB;
  Database changed
  mysql> CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表
  Query OK, 0 rows affected (0.04 sec)

  mysql> select * from runoob_transaction_test;
  Empty set (0.01 sec)

  mysql> begin;  # 开始事务
  Query OK, 0 rows affected (0.00 sec)

  mysql> insert into runoob_transaction_test value(5);
  Query OK, 1 rows affected (0.01 sec)

  mysql> insert into runoob_transaction_test value(6);
  Query OK, 1 rows affected (0.00 sec)

  mysql> commit; # 提交事务
  Query OK, 0 rows affected (0.01 sec)

  mysql>  select * from runoob_transaction_test;
  +------+
  | id   |
  +------+
  | 5    |
  | 6    |
  +------+	 
  2 rows in set (0.01 sec)

  mysql> begin;    # 开始事务
  Query OK, 0 rows affected (0.00 sec)

  mysql>  insert into runoob_transaction_test values(7);
  Query OK, 1 rows affected (0.00 sec)

  mysql> rollback;   # 回滚
  Query OK, 0 rows affected (0.00 sec)

  mysql>   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入
  +------+
  | id   |
  +------+
  | 5    |
  | 6    |
  +------+
  2 rows in set (0.01 sec)

  mysql>
  ~~~

+ Mysql ALTER命令

  当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。

  ~~~
  mysql> create table testalter_tbl
      -> (
      -> i INT,
      -> c CHAR(1)
      -> );
  mysql> SHOW COLUMNS FROM testalter_tbl;
  +-------+---------+------+-----+---------+-------+
  | Field | Type    | Null | Key | Default | Extra |
  +-------+---------+------+-----+---------+-------+
  | i     | int(11) | YES  |     | NULL    |       |
  | c     | char(1) | YES  |     | NULL    |       |
  +-------+---------+------+-----+---------+-------+


  ~~~

  **删除与添加**

  `mysql> ALTER TABLE testalter_tbl  DROP i`  删除上述创建的i 字段

  `ALTER TABLE testalter_tbl ADD i INT` 添加 i 字段并且定义数据类型

  如果需要指定位置，则可以用FIRST（第一列） AFTER 字段名 （位于某个之后）来改变

  `ALTER TABLE testalter_tbl ADD I INT AFTER C` 在C之后添加 i 字段

  

  **修改类型**

  如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。

  ` ALTER TABLE testalter_tbl MODIFY c CHAR(10)`  将字符C的类型从char(1)变为char(10)

  使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。

  `mysql> ALTER TABLE testalter_tbl CHANGE i j BIGINT`

  当你修改字段时，你可以指定是否包含值或者是否设置默认值。

  `mysql> ALTER TABLE testalter_tbl    `

  ` -> MODIFY j BIGINT NOT NULL DEFAULT 100;`

  设置了字段j 为 NOT NULL  且默认为100

  **修改字段默认值**

  ```
  mysql> ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000; 设置
  mysql> ALTER TABLE testalter_tbl ALTER i DROP DEFAULT; 删除
  ```

  **修改表名**

  `mysql> ALTER TABLE testalter_tbl RENAME TO alter_tbl;`  将test...名字变为altr_tbl

  

+ Mysql 索引

  相当于目录，加快Mysql查询速度

  创建索引时，你需要确保该索引是应用在	SQL 查询语句的条件

  **创建索引**

  ```
  CREATE INDEX indexName ON mytable(username(length)); 

  如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。
  ```

  **修改表结构**（添加索引）

  ~~~
  ALTER table tableName ADD INDEX indexName(columnName)		
  ~~~

  **创建表的时候指定**

  ~~~
  CREATE TABLE mytable(  

  ID INT NOT NULL,   

  username VARCHAR(16) NOT NULL,  

  INDEX [indexName] (username(length))  

  );  
  ~~~

  **删除索引**

  ~~~
  DROP INDEX [indexName] ON mytable; 
  ~~~

  ###唯一索引

  它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

  **创建索引**

  ~~~
  CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
  ~~~



  创建方式与之前一样 只是加了个UNIQUE表示唯一索引

  **使用ALTER命令 删除索引**

  - **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)**

    该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL

  - **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。

  - **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。

  - **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

  同样 删除索引可以用 ALTER TABLE tbl_name DROP INDEX (index_name)；

  也可以使用ALTER 命令删除和添加主键

  ```
  ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
  ALTER TABLE testalter_tbl DROP PRIMARY KEY;
  ```

  **显示索引**

  ```
  mysql> SHOW INDEX FROM table_name; \G  可以添加\G来格式化输出
  ```
  ~~~



+ Mysql连接池

  数据库连接池（Connection pooling）是程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由程序动态地对池中的连接进行申请，使用，释放。

  在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠。

  **数据库连接池的基本思想**：**就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。**我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接

  创建数据库连接池大概有3个步骤：

  ① 创建ConnectionPool实例，并初始化创建10个连接，保存在Vector中（线程安全）单例模式实现
  ② 实现getConnection()从连接库中获取一个可用的连接
  ③ returnConnection(conn) 提供将连接放回连接池中方法

### Nodejs 连接mysql

+ 创建连接

  `mysql.createConnection(obj)`	

  ~~~
  var mysql = require('mysql')
  var connection = mysql.createConnection({

    host     : '127.0.0.1',
    user     : 'root',
    password : 'root123', //密码
    port: '3306', //端口 
    database: 'my_news_test', /连接的数据库
  });

  connection.connect();
   var sql = 'SELECT * FROM try';
  connection.query(sql, function (error, results, fields) {
    if (error) throw error;
    console.log(results);
  });
  connection.end(); //结束连接，end接受一个回调函数，并且在query之后触发
  connection.destroy() 立即结束
  ~~~

+ 增删改查

  建立一个查询的最基本的方法是在一个连接实例(像Connection, Pool, PoolNamespace 或其他相似的对象)上调用 .query() 方法

  query() 最简单的形式是 .query(sqlString, callback), 第一个参数是SQL语句，第二个参数是回调函数：

   .query(sqlString, values, callback)    values 参数会覆盖掉选项对象中的 values

  用.query方法配合sql语句可实现数据库的增删改查

  ~~~
  connection.query(sql, function (error, results, fields) {
    if (error) throw error;
    console.log(results);
  });

  增
  var addVip = 'insert into seckill(name,number) values(?,?)';
  var param = ['100元秒杀家教机',100];
  connection.query(addVip, param, function(error, result){})

  删
  var addVip = 'delete from seckill where seckill_id = 1005';
  connection.query(addVip, function(error, result){})

  改
  connection.query('SELECT * FROM `books` WHERE `author` = ?', ['David'], function (error, results, fields) )

  查
  var DATABASE = "node";
  var TABLE="seckill"
  connection.query('use '+DATABASE);
  connection.query('select * from '+TABLE, function(error, results, fields){}
  ~~~

  ​

+ 创建连接池

  `createPool(obj)` 参数同createConnection

  ~~~
  var mysql = require("mysql");
  var pool = mysql.createPool({
      host: '127.0.0.1',    
      user: 'root',
      password:'12345',
      port:'3306',
      database:'node'
  });
  //监听connection事件

  pool.on('connection', function(connection) { 

      connection.query('select * from seckill', function(error, results, fields){
          if (error) {
              throw error;
          }
          if (results) {
              for(var i = 0; i < results.length; i++)
              {
                  console.log('%s\t%s',results[i].name,results[i].end_time);
              }
          }
      });

  });

  //连接池可以直接使用，也可以共享一个连接或管理多个连接（引用官方示例）
  //直接使用

  pool.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {

      if (err) throw err;

      console.log('The solution is: ', rows[0].solution);

  });
  ~~~


  //共享连接
  function myQuery(sql)
  {
      pool.getConnection(function(err, connection) {

          connection.query(sql, function(err, result) {   
    
              console.log(result);
              //释放连接
              connection.release();
    
          });
    
    
          //Error: Connection already released,应该每次到连接池中再次获取
          // connection.query( 'SELECT * FROM seckill;', function(err, result) {
    
    
          //  console.log(result);
    
          //  connection.release();
    
          // });
    
      });
  }

  myQuery('SELECT * FROM seckill;');
  myQuery('SELECT * FROM seckill;');
  ~~~

  1.连接池的创建，使用createPool方法，options和createConntion一致； 
  2.其它连接池配置选项　

  - waitForConnections

  当连接池没有连接或超出最大限制时，设置为true且会把连接放入队列，设置为false会返回error

  - connectionLimit 
    连接数限制，默认：10
  - queueLimit 
    最大连接请求队列限制，设置为0表示不限制，默认：0

+ 断开重连

  ~~~
  var mysql = require('mysql');

  var db_config = {

      host: '127.0.0.1',    
    
      user: 'root',
    
      password:'12345',
    
      port:'3306',
    
      database:'node'

  };

  var connection;

  function handleDisconnect() {

      connection = mysql.createConnection(db_config);                                              
    
      connection.connect(function(err) {             
    
          if(err) {                                    
    
              console.log('进行断线重连：' + new Date());
    
              setTimeout(handleDisconnect, 2000);   //2秒重连一次
              return;
    
          }        
    
          console.log('连接成功'); 
    
      });                                                                          
    
      connection.on('error', function(err) {
    
          console.log('db error', err);
    
          if(err.code === 'PROTOCOL_CONNECTION_LOST') {
    
              handleDisconnect();                        
    
          } else {                                     
              throw err;                                
          }
    
      });

  }

  handleDisconnect();
  ~~~

  ​

+ 防止SQL注入

  可以使用pool.escape()和connect.escape()，示例代码

  ~~~
  connection.query('SELECT * FROM userinfo WHERE id = ' + pool.escape('5 OR ID = 6') ,function(err,result){})
  ~~~

  ~~~